"""
module_engine.py

Core module for TARS-AI responsible for:
- Predicting user intents and determining required modules.
- Executing tool-specific functions like web searches and vision analysis.

This is achieved using a pre-trained Naive Bayes classifier and TF-IDF vectorizer.
"""

# === Standard Libraries ===
import os
import joblib
from datetime import datetime

# === Custom Modules ===
from module_websearch import search_google, search_google_news
from module_vision import describe_camera_view
from module_config import load_config

# Load configuration
config = load_config()

# === Constants ===
MODEL_FILENAME = 'engine/pickles/naive_bayes_model.pkl'
VECTORIZER_FILENAME = 'engine/pickles/module_engine_model.pkl'

# === Load Models ===
try:
    if not os.path.exists(VECTORIZER_FILENAME):
        raise FileNotFoundError("Vectorizer file not found.")
    if not os.path.exists(MODEL_FILENAME):
        raise FileNotFoundError("Model file not found.")
    nb_classifier = joblib.load(MODEL_FILENAME)
    tfidf_vectorizer = joblib.load(VECTORIZER_FILENAME)

except FileNotFoundError as e:
    # Attempt to train models if files are missing
    import module_engineTrainer
    module_engineTrainer.train_text_classifier()
    try:
        nb_classifier = joblib.load(MODEL_FILENAME)
        tfidf_vectorizer = joblib.load(VECTORIZER_FILENAME)
    except Exception as retry_exception:
        raise RuntimeError("Critical error while loading models.") from retry_exception


# === Functions ===
def predict_class(user_input):
    """
    Predicts the class and its confidence score for a given user input.

    Parameters:
        user_input (str): The input text from the user.

    Returns:
        tuple: Predicted class and its probability score.
    """
    query_vector = tfidf_vectorizer.transform([user_input])
    predictions = nb_classifier.predict(query_vector)
    predicted_probabilities = nb_classifier.predict_proba(query_vector)

    predicted_class = predictions[0]
    max_probability = max(predicted_probabilities[0])

    # Return None if confidence is below threshold
    if max_probability < 0.75:
        return None, max_probability


    # Format the value as a percentage with 2 decimal places
    formatted_probability = "{:.2f}%".format(max_probability * 100)
    print(f"TOOL: Using Tool {predicted_class} ({formatted_probability})")
    return predicted_class, max_probability


def check_for_module(user_input):
    """
    Determines the appropriate module to handle the user's input based on predictions.

    Parameters:
        user_input (str): The input text from the user.

    Returns:
        str: A response generated by the determined module or a default message if no module is needed.
    """
    # Get predicted class and probability from the prediction model
    predicted_class, probability = predict_class(user_input)

    # Handle case for no image generating tool
    if predicted_class == "sdmodule-generate" and config['STABLE_DIFFUSION']['enabled'] == 'False':
        return "Unable, no image generating tool available"

    # Handle override cases
    if "draw me a" in user_input.lower():
        predicted_class = "sdmodule-generate"
        print("Override sdmodule-generate")

    elif "search google" in user_input.lower():
        predicted_class = "Search"

    # Return appropriate responses based on the predicted class
    if predicted_class == "Weather":
        weather_info = search_google(user_input)
        return f"*Using tool Web Search* Use the following results from a real-time web search: {weather_info}"

    if predicted_class == "News":
        result = search_google_news(user_input)
        return f"*Using tool Web Search* Summarize the news from the following web search results: {result}"

    if predicted_class == "Vision":
        result = describe_camera_view()
        return f"*Using tool Vision* The following is a summary of what TARS can see: {result}"

    if predicted_class == "Search":
        result = search_google(user_input)
        return f"*Using tool Web Search* Use this answer from Google to respond to the user: {result}"

    if predicted_class == "Goodbye":
        return "*User is leaving the chat politely*"

    if predicted_class == "sdmodule-generate":
        return "sdmodule-generate"

    if predicted_class == "Chat":
        return "No_Tool"

    if predicted_class == "Mute":
        return "Mute"

    # Default response if no suitable module is found
    return "No_Tool"

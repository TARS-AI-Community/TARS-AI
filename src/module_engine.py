"""
module_engine.py

Core module for TARS-AI responsible for:
- Predicting user intents and determining required modules.
- Executing tool-specific functions like web searches, vision analysis, and volume control.

This is achieved using a pre-trained Naive Bayes classifier and TF-IDF vectorizer.
"""

# === Standard Libraries ===
import os
import joblib
from datetime import datetime
import subprocess
import re

# === Custom Modules ===
from module_websearch import search_google, search_google_news
from module_vision import describe_camera_view
from module_volume import RaspbianVolumeManager  # Import the volume manager

# === Constants ===
MODEL_FILENAME = 'engine/pickles/naive_bayes_model.pkl'
VECTORIZER_FILENAME = 'engine/pickles/module_engine_model.pkl'

# === Load Models ===
try:
    if not os.path.exists(VECTORIZER_FILENAME):
        raise FileNotFoundError("Vectorizer file not found.")
    if not os.path.exists(MODEL_FILENAME):
        raise FileNotFoundError("Model file not found.")
    nb_classifier = joblib.load(MODEL_FILENAME)
    tfidf_vectorizer = joblib.load(VECTORIZER_FILENAME)

except FileNotFoundError as e:
    # Attempt to train models if files are missing
    import module_engineTrainer
    module_engineTrainer.train_text_classifier()
    try:
        nb_classifier = joblib.load(MODEL_FILENAME)
        tfidf_vectorizer = joblib.load(VECTORIZER_FILENAME)
    except Exception as retry_exception:
        raise RuntimeError("Critical error while loading models.") from retry_exception

# === Functions ===
def predict_class(user_input):
    """
    Predicts the class and its confidence score for a given user input.

    Parameters:
        user_input (str): The input text from the user.

    Returns:
        tuple: Predicted class and its probability score.
    """
    query_vector = tfidf_vectorizer.transform([user_input])
    predictions = nb_classifier.predict(query_vector)
    predicted_probabilities = nb_classifier.predict_proba(query_vector)

    predicted_class = predictions[0]
    max_probability = max(predicted_probabilities[0])

    # Return None if confidence is below threshold
    if max_probability < 0.75:
        return None, max_probability
    print(f"TOOL: Using Tool {predicted_class} at {max_probability}")
    return predicted_class, max_probability


def check_for_module(user_input):
    """
    Determines the appropriate module to handle the user's input based on predictions.

    Parameters:
        user_input (str): The input text from the user.

    Returns:
        str: A response generated by the determined module or a default message if no module is needed.
    """
    predicted_class, probability = predict_class(user_input)

    if "search google" in user_input.lower():
        predicted_class = "Search"

    if predicted_class:
        if predicted_class == "Weather":
            weather_info = search_google(user_input)
            return f"*Using tool Web Search* Use the following results from a realtime web search: {weather_info}"

        elif predicted_class == "News":
            result = search_google_news(user_input)
            return f"*Using tool Web Search* Summarize the news from the following web search results: {result}"

        elif predicted_class == "Vision":
            result = describe_camera_view()
            return f"*Using tool Vision* The following is a summary of what TARS can see: {result}"

        elif predicted_class == "Search":
            result = search_google(user_input)
            return f"*Using tool Web Search* Use this answer from Google to respond to the user: {result}"

        elif predicted_class == "Goodbye":
            return "*User is leaving the chat politely*"

        elif predicted_class == "Chat":
            return "No_Tool"

        # Volume control intent
        elif predicted_class == "Volume":
            volume_manager = RaspbianVolumeManager()  # Create volume manager instance

            if "increase" in user_input.lower():
                current_volume = volume_manager.get_volume()
                if current_volume is not None:
                    new_volume = min(current_volume + 10, 100)
                    volume_manager.set_volume(new_volume)
                    return f"Volume increased to {new_volume}%. "
            
            elif "decrease" in user_input.lower():
                current_volume = volume_manager.get_volume()
                if current_volume is not None:
                    new_volume = max(current_volume - 10, 0)
                    volume_manager.set_volume(new_volume)
                    return f"Volume decreased to {new_volume}%. "
            
            elif "set" in user_input.lower():
                # Extract volume percentage from user input
                match = re.search(r'(\d{1,3})%', user_input)
                if match:
                    volume = int(match.group(1))
                    if 0 <= volume <= 100:
                        volume_manager.set_volume(volume)
                        return f"Volume set to {volume}%. "
                    else:
                        return "Please provide a valid volume between 0 and 100."
                else:
                    return "Please specify the volume percentage."
            
            else:
                return "Volume control not recognized."

        elif predicted_class == "Mute":
            return "Mute"

    # Default response if no suitable module is found
    return "I couldn't find a module for your request."
